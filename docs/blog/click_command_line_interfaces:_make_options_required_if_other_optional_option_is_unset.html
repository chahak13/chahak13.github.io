<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-11-20 Sun 01:21 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Click Command Line Interfaces: Make options required if other optional option is unset</title>
<meta name="author" content="Chahak Mehta" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="../style.css" type="text/css"/>
</head>
<body>
<div id="preamble" class="status">
<div id="updated">Updated: 2022-11-19 Sat 19:42</div>
<nav>
<a href="/">&lt; Home</a>
</nav>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Click Command Line Interfaces: Make options required if other optional option is unset</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5d71d98">1. Click Command Line Interfaces: Make options required if other optional option is unset</a>
<ul>
<li><a href="#orgc188004">1.1. Answer 1</a></li>
<li><a href="#orge53c15f">1.2. Answer 2</a></li>
<li><a href="#org09bd954">1.3. Answer 3</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-org5d71d98" class="outline-2">
<h2 id="org5d71d98"><span class="section-number-2">1.</span> <a href="https://stackoverflow.com/questions/44247099/click-command-line-interfaces-make-options-required-if-other-optional-option-is">Click Command Line Interfaces: Make options required if other optional option is unset</a></h2>
<div class="outline-text-2" id="text-1">
<p>
When writing a command-line interface (CLI) with the Python <a href="http://click.pocoo.org/6/">click library</a>, is it possible to define e.g. three options where the second and third one are only required if the first (optional) one was left unset?
My use case is a log-in system which allows me to authenticate either via an <code>authentication token</code> (option 1), or, alternatively, via <code>username</code> (option 2) and <code>password</code> (option 3). 
If the token was given, there is no need to check for <code>username</code> and <code>password</code> being defined or prompting them. Otherwise, if the token was omitted then <code>username</code> and <code>password</code> become required and must be given.
Can this be done somehow using callbacks?
My code to get started which of course does not reflect the intended pattern:
</p>
<pre class="example" id="org474fc14">
@click.command()
@click.option('--authentication-token', prompt=True, required=True)
@click.option('--username', prompt=True, required=True)
@click.option('--password', hide_input=True, prompt=True, required=True)
def login(authentication_token, username, password):
    print(authentication_token, username, password)

if __name__ == '__main__':
    login()

</pre>

<p>
Comments
</p>
</div>

<div id="outline-container-orgc188004" class="outline-3">
<h3 id="orgc188004"><span class="section-number-3">1.1.</span> Answer 1</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This can be done by building a custom class derived from <code>click.Option</code>, and in that class over riding the <code>click.Option.handle_parse_result()</code> method like:
</p>
<pre class="example" id="org1139ad8">
import click

class NotRequiredIf(click.Option):
    def __init__(self, *args, **kwargs):
        self.not_required_if = kwargs.pop('not_required_if')
        assert self.not_required_if, "'not_required_if' parameter required"
        kwargs['help'] = (kwargs.get('help', '') +
            ' NOTE: This argument is mutually exclusive with %s' %
            self.not_required_if
        ).strip()
        super(NotRequiredIf, self).__init__(*args, **kwargs)

    def handle_parse_result(self, ctx, opts, args):
        we_are_present = self.name in opts
        other_present = self.not_required_if in opts

        if other_present:
            if we_are_present:
                raise click.UsageError(
                    "Illegal usage: `%s` is mutually exclusive with `%s`" % (
                        self.name, self.not_required_if))
            else:
                self.prompt = None

        return super(NotRequiredIf, self).handle_parse_result(
            ctx, opts, args)

</pre>
<p>
To use the custom class, pass the <code>cls</code> parameter to <code>click.option</code> decorator like:
</p>
<pre class="example" id="orgedd5995">
@click.option('--username', prompt=True, cls=NotRequiredIf,
              not_required_if='authentication_token')

</pre>
<p>
This works because click is a well designed OO framework. The <code>@click.option()</code> decorator usually instantiates a <code>click.Option</code> object but allows this behavior to be overridden with the <code>cls</code> parameter. So it is a relatively easy matter to inherit from <code>click.Option</code> in our own class and over ride the desired methods.
In this case we over ride <code>click.Option.handle_parse_result()</code> and disable the need to <code>user/password</code> if <code>authentication-token</code> token is present, and complain if both <code>user/password</code> are <code>authentication-token</code> are present.
Note: This answer was inspired by <a href="https://stackoverflow.com/a/37491504/7311767">this answer</a>
</p>
<pre class="example" id="orgdf1ac69">
@click.command()
@click.option('--authentication-token')
@click.option('--username', prompt=True, cls=NotRequiredIf,
              not_required_if='authentication_token')
@click.option('--password', prompt=True, hide_input=True, cls=NotRequiredIf,
              not_required_if='authentication_token')
def login(authentication_token, username, password):
    click.echo('t:%s  u:%s  p:%s' % (
        authentication_token, username, password))

if __name__ == '__main__':
    login('--username name --password pword'.split())
    login('--help'.split())
    login(''.split())
    login('--username name'.split())
    login('--authentication-token token'.split())

</pre>
<p>
from <code>login('--username name --password pword'.split())</code>:
</p>
<pre class="example" id="orgc86f7b2">
t:None  u:name  p:pword

</pre>
<p>
from <code>login('--help'.split())</code>:
</p>
<pre class="example" id="org4fa6845">
Usage: test.py [OPTIONS]

Options:
  --authentication-token TEXT
  --username TEXT              NOTE: This argument is mutually exclusive with
                               authentication_token
  --password TEXT              NOTE: This argument is mutually exclusive with
                               authentication_token
  --help                       Show this message and exit.

</pre>

<p>
Comments:
</p>
</div>
</div>


<div id="outline-container-orge53c15f" class="outline-3">
<h3 id="orge53c15f"><span class="section-number-3">1.2.</span> Answer 2</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Slightly improved <a href="https://stackoverflow.com/a/44349292/7311767">Stephen Rauch&rsquo;s answer</a> to have multiple mutex parameters.
</p>
<pre class="example" id="org59a88d8">
import click

class Mutex(click.Option):
    def __init__(self, *args, **kwargs):
        self.not_required_if:list = kwargs.pop("not_required_if")

        assert self.not_required_if, "'not_required_if' parameter required"
        kwargs["help"] = (kwargs.get("help", "") + "Option is mutually exclusive with " + ", ".join(self.not_required_if) + ".").strip()
        super(Mutex, self).__init__(*args, **kwargs)

    def handle_parse_result(self, ctx, opts, args):
        current_opt:bool = self.name in opts
        for mutex_opt in self.not_required_if:
            if mutex_opt in opts:
                if current_opt:
                    raise click.UsageError("Illegal usage: '" + str(self.name) + "' is mutually exclusive with " + str(mutex_opt) + ".")
                else:
                    self.prompt = None
        return super(Mutex, self).handle_parse_result(ctx, opts, args)

</pre>
<p>
use like this:
</p>
<pre class="example" id="org98e65ad">
@click.group()
@click.option("--username", prompt=True, cls=Mutex, not_required_if=["token"])
@click.option("--password", prompt=True, hide_input=True, cls=Mutex, not_required_if=["token"])
@click.option("--token", cls=Mutex, not_required_if=["username","password"])
def login(ctx=None, username:str=None, password:str=None, token:str=None) -&gt; None:
    print("...do what you like with the params you got...")

</pre>

<p>
Comments:
</p>
</div>
</div>


<div id="outline-container-org09bd954" class="outline-3">
<h3 id="org09bd954"><span class="section-number-3">1.3.</span> Answer 3</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Here&rsquo;s another variant, in which has not<sub>required</sub><sub>if</sub> must be specified with the snake<sub>case</sub> variant, required is used rather than prompt, and importantly, it works if the other arguments are passed through environment variables rather than on the command line by using ctx.command.get<sub>params</sub>(&#x2026;) and param.consume<sub>value</sub>(&#x2026;):
</p>
<pre class="example" id="orgd7d3f62">
import click


class Mutex(click.Option):
    def __init__(self, *args, **kwargs):
        self.not_required_if: list = kwargs.pop("not_required_if")

        assert self.not_required_if, "'not_required_if' parameter required"
        kwargs["help"] = (kwargs.get("help", "") + "Option is mutually exclusive with " + ", ".join(self.not_required_if) + ".").strip()
        super(Mutex, self).__init__(*args, **kwargs)

    def handle_parse_result(self, ctx, opts, args):
        current_opt: bool = self.consume_value(ctx, opts)
        for other_param in ctx.command.get_params(ctx):
            if other_param is self:
                continue
            if other_param.human_readable_name in self.not_required_if:
                other_opt: bool = other_param.consume_value(ctx, opts)
                if other_opt:
                    if current_opt:
                        raise click.UsageError(
                            "Illegal usage: '" + str(self.name)
                            + "' is mutually exclusive with "
                            + str(other_param.human_readable_name) + "."
                        )
                    else:
                        self.required = None
        return super(Mutex, self).handle_parse_result(ctx, opts, args)

</pre>

<p>
Comments:
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr/>
<footer>
<div class="generated">
Created with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.6)
</div>
</footer>
</div>
</body>
</html>